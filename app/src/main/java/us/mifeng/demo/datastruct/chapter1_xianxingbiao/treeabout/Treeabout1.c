//
// Created by hooneyLL on 2/9/21.
//
/*
  树是n个结点的有限集合，当n=0时是一棵空树
  树的表示：1。使用 集合的方式来实现  2。凹入表示法 3。广义表的实现
  根结点：非空树中无前驱的结点；
  结点的度：结点拥有的子树或者分支的总数
  树的度：树内各结点度的最大值；
  叶子结点：度为0的结点；
  二叉树：所有的树都可以转化为唯一对应的二叉树，
  二叉树是n个结点的集合，若 n=0 则为空树，或者是由一个根结点和两棵互不相交的分别称为左右子树的二叉树组成，
 特点：
  1）每个结点最多有两个孩子（二叉树中不存在度大于二的结点）
  2）二叉树的子树有左右之分，其顺序不能颠倒；
  3）二叉树可以是空的集合，根可以有空的左子树或者空的右子树

  二叉树不是树的特殊情况，是两种概念；
  二叉树即使只有一个孩子，任然要区分是左子树还是右子树，而对于树，如果只有一个结点，就不需要区分是左还是右的问题
  编码：将数据文件转化成由0，1 组成的二进制串，称之为编码；
  编码有等长和不等长编码；

  二叉树的抽象数据类型：
   ADT BinaryTree{
   数据对象D：具有相同特性的数据元素的集合；
   数据关系R：若D 等于空，则R等于空，
             若D 不等于空，则R={H},H是如下关系
                    （1）root唯一；关于根的说明
                    （2）各个子树之间互不相交；
                    （3）
   基本操作：
   }ADT BinaryTree

具体操作：
   1.创建二叉树
   2.前序遍历
   3.中序遍历
   4.后序遍历

   二叉树的性质；
   1.在二叉树的第i层上最多有 2的（i-1)次方的结点（i>=1）（用数学归纳法证明）
    第 i 层上最少有 1 个结点
   2.深度为k的二叉树至多有 (2 的 k 次方 -1 )个结点（k>=1）
    证明：将所有层的结点加起来即可
        all= 2^0 + 2^1 +2^2 +...+ 2^(k-1)
          根据等比数列性质： sn=a1(1-q^n)/1-q 带入上式
          =2^k -1
          深度为k的二叉树最少应该有 k 个结点。
     3.对于任意一棵二叉树T，其中叶子结点为 n0 ,度为2的结点为 n2, 则 n0=n2+1;
       总边数 =总的结点数（n) -1；
       总边数=2 *度为2的树(n2) + 度为1的树（n1）
       总结点树(n)= 度为1的数 (n1) + 度为2 的数(n2)  + 度为零的树（n0）
       以上三式结合得 n0=n2+1;即 叶子结点总数= 度为2 的结点的总数 +1

     关于满二叉树和完全二叉树
     一棵深度为k且有 2^(k) -1个结点的二叉树称为满二叉树；
     满二叉树的性质：
        1.每一层上的结点数目都达到最大结点数 （每层的结点数为 2^(n-1)次放个结点 ，其中n为层数）
        2.叶子结点全在最底层；
    对满二叉树的结点编号，编号规则为从根结点开始，自上而下，自左至右
    满二叉树在同样深度的二叉树中结点个数最多；
    满二叉树在同样深度的二叉树中叶子结点数最多；

    完全二叉树：
    深度为k的具有n个结点的二叉树，当且仅当其每一个结点的深度都与深度为k 的满二叉树中编号 1~n 的结点对应时，
    称该二叉树为完全二叉树；
    特点：
     1.叶子只可能分布在层次最大的两层上；
     2.对任一结点，如果其右子树的最大层次为 i,则其左子树的最大层次必为 i或 i+1;
    完全二叉树的性质：
    （4）具有n个结点的完全二叉树的深度为 「log2^n」+1
     eg 假设一棵完全二叉树有 12个结点，则它的深度为
     「log2^12」它是介于 log2^8 ~ log2^14 即 3~4之间，因此该树的深度为 3+1=4 因为是向下取整的
     性质4表明了完全二叉树的结点数 n 和完全二叉树的深度 k之间的关系；

     性质（5）如果对一棵有n个结点的完全二叉树（深度为「log2^n』+1）,若结点按层序编号（从第一层到 「log2^n」+1层，
            每层从左到右，）则对任一结点 i （1=<i<=n）有：
            @1.如果i=1，则结点i是二叉树的根，无双亲；如果 i> 1,则其双亲结点为「i/2」（向下取整）；
            @2.如果2i>n,则结点 i 为叶子结点，无左孩子，否则 其左孩子是结点2i；
            @3.如果2i +1>n,则结点i 无右孩子，否则，其右孩子结点为 2i +1;
            性质5表明了双亲结点 编号与 孩子结点编号之间的关系。

       二叉树的顺序存储：
       按照满二叉树的结点层次编号，依次存放二叉树中数据元素。注意必须是连续编号，比如前面的结点 i没有孩子结点，但是 i+1结点有
       孩子，则i +1 孩子编号时也要算上i孩子的编号，即使 i 孩子没有孩子 但是编号也得继续编
       二叉树的顺序表示方法：

       #define MAXSIZE 100;
       typedef TElemType SqBiTree[MAXSIZE];
       SqBiTreee bt;
       顺序存储比较适合满二叉树的存储，如果是只有单支右边二叉树一枝的，则特别浪费空间，
        使用顺序方式存储二叉树的画法，请参看drawable/seqtree.jpg

        二叉树的链式存储：
        typedef struct BitNode{
        TElemType data;
        struct  BitNode *lChild,*rChild;
        }BitNode,*BiTree;

        二叉树的链式存储方式请查看 drawable/erchalianbiao.jpg 图
        在n 个结点的二叉链表中，有 n+1 个空指针域
        根节点没有双亲
  三叉链表 ：便于找到前驱，即找到双亲；
     typedef struct TriTNode{
      TElemType data;
      strcut TriTNode * lChild,*rChild, *parent;
     }TriTNode,*TriTree;

     三叉链表请查看 drawble/sanchalink.jpg图的实现

     二叉树的层次遍历：根左右 （前序遍历） 左根右（中序遍历）左右根（后序遍历）
     顺着某一条搜索路径巡防二叉树中的结点，使得每个结点均被访问一次，而且仅访问一次 、
     遍历的目的： 得到树中所有结点的一个线性排列。


*/

