#include <stdio.h>
#include <string.h>
#include <stdlib.h>
/* 
有向图的邻接表的数据结构描述

    //1.边结点的数据结构描述
    typedef struct ArcNode{ //边的信息
    int adjver;    //表示顶点在数组中的下标
    struct ArcNode * next;  //指向下条边的指针
    WeightType info;  //权值，可有可无，有就存储，没有就不存储
    }ArcNode;

    //2.顶点数据描述
    typedef struct{
    int data;      //顶点的信息
    ArcNode *first;  //指向边的指针
    } VNode;

    //3.图的结构体描述
    typedef struct {
    VNode adjList[maxSize] ;//图中存放的节点数目为数组
    int vexNum,arcNum;          //图中顶点和边数
    }AGraph;

二、无向图的使用：
  顶点的结点C结构设计：data(存放顶点的值)--first()
  边结点的数据结构设计：
  vi（起点）----viNext（与起点vi相关的下个顶点）--vj(终点)---vjNext(与终点vj的下个结点)

 */

typedef struct {

}vNoce;



/*

prim算法：
生成树是指通过删除一些边，使图中的环被消除；
生成最小生成树的：就是指删除一些边后，使生成的树的权值最小
生成最小生成树是不唯一的，如果有两个边的权值是相等的情况下，选择不同，生成的最小生成树也不同

如何构建最小生成树：
1.先找第一个结点，将其并入最小生成树比如A0,
2.找出图中和A0结点相关的所有相关的边，挑选其中权值最小的边并入刚生
  成的最小生成树中，比如A1,然后下个顶点，找和该结点相关的边，然后挑
  权值最小的并入生成树，（注意：将已经并入结点的边不再考虑，否则不能
  打破环）

 prim生成最小树的算法  时间复杂度0（n~n =n*n）--》适用于稠密图
 
 n:代表结点数目；
 MGraph[v][j]:表示当前并入生成树中的顶点v到顶点j的权值
 lowCost[]:通过索引值来存放每个索引对应的权值，有边就是权值，无边就是无穷
 */
void prim(int n,float MGraph[][n],int vo,float *sum){
  int lowCost[n]; //表示当前生成树到图中其他顶点的边的最小权值 ，比如lowCost[0]
                  //表示当前生成树到顶点0的权值最小的那条边权值
  int vSet[n];    //表示当数组n所指位置的顶点被赋值为1时，表示该结点被并入当前生成树中
                  //比如：vSet[0]=1,表示数组中0下标所指的那个结点已经被并入生成树中
  int v;         //表示当前刚刚并入生成树的结点
  int k,min;      //min存放最小的权值，二 

  for (int i = 0; i < n; i++)
  {min=InitF; //随便放一个初始值
   lowCost[i]=MGraph[v0][i]; //lowCost初始化时，如果两个顶点之间有边，则存放权值，没有边存放无穷
   vSet[i]=0;
  }
  v=v0; vSet[v]=1;  sum=0;
  for (int j= 0; j < n; j++)
  {
    if (vSet[j]==0 && lowCost[j]<min) //如果当前结点还没有并入生成树，而且min不是最小，则要将其赋值给敏
    {min=lowCost[j];
     k=j;
    }
    vSet[k]=1; //表示刚才的k结点被并入最小生成树
    v=k;       //表示k是当前并入生成树的结点
    sum+=min;
    for (int  j = 0; j < n; j++)
    {
      if (vSet[j]==0 && lowCost[j]>MGraph[v][j]) //修改lowCost的值
      {
        lowCost[j]=MGraph[v][j];
      }
    }
  }
}

/* 
 Kruskal算法：时间复杂度为 O(eloge)--->适用于稀疏图
 并查集：如何帮助生成树中是否有环的工具：
 每次打算并入一条边的时候，首先检查一下
 这条边的两个顶点是否属于同一棵树（**不属于同一棵树的意思是指这两个顶点的父结点不是同一个的意思）
 ，如果这两顶点不属于同一棵树时，将其并入生成树，
 并把其中一个顶点在右边的树中的根结点挂在另一个结点上，作为其孩子结点  
 其中的数据结构的描述分为边的关系的结构体和顶点和双亲关系的数组
 注意：双亲关系的数组起初时，每个顶点是独立的因此，它的根结点是它自己，只有在生成树发
 生变化时，前面是顶点 后面就是其双亲 比如 （ 0 0）：0结点的双亲就是0，表示0是根结点
 (1 0):1结点的双亲就是0  (2 4):2结点的双亲就是4;
 而前面的边的关系是通过结构体来描述的，分别是起始结点 ，结束结点和 权值
 因此要定义一个结构体
 typedef struct{
   int a,b;
   int weight;
 }Road;

 算法思想：为了使生成树边的权值之和最小，则应使生成树中每一条边的权值尽可能小
 具体实现算法：先构造一个只含有n个顶点的圈子图SG,然后从权值最小的边开始，若它的添加
              不是SG图中产生回路，则在SG上加上这条边，如此重复，直至加上n-1条边为止。
  克鲁斯卡尔算法也叫加边法          
 */

/* 
关键路径：
 以一条有向图的流程来模拟工程完成的流程：
 1.工程完成的时间为：从有向图的源点(  没有前驱的点 )到汇点(最后遍历的一个结点)的最长路径（指的是权值最大的意思）
 2.关键活动:该弧上的权值增加将使有向图的最长路径的长度增加
 3.如何求关键活动：关键活动指的是该活动的最早开始时间=该活动的最迟开始时间
 4.顶点是事件，弧是活动 ，弧上的权值是该活动需要持续的时间
 5.事件的最早发生时间：ve(j)=从源点到顶点j的最长路径的长度
 6.事件的最迟发生时间：vl(j)=从顶点j到汇点的最短路径的长度
 二、关于活动
 假设第i条弧为<j,k>，注意j为弧尾，k为弧头
 则对于第i项活动  “活动（j-k两个顶点之间的弧）的最早开始时间为ee(i)=弧尾事件的最早发生时间（ve(j)）
  即：ee(i)=ve(j);

  活动(弧)的“最迟开始时间el(i)=弧头的最晚开始时间vl（k）-dut(<j,K>)(表示活动持续的时间，两个顶点之间的权值)；
  即：el(i)=vl(k)-dut(<j,k>);

 */
