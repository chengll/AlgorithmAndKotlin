/*小根堆是指根元素的值小于左孩子和小于右孩子(包括分支也是同样的规则，根大于左右孩子)（根是最小值），
而对于大根堆，则是根大于左孩子或者右孩子，堆对应的是一棵完全二叉树 （根是最大值）。
注意：但是左右孩子的大小关系还未确定
 小根堆的调整过程：
 1.然后将堆中的结点从1---n开始编号，输出堆顶元素，然后找编号中最后一个元素放在根的位置；
 2.将根结点和左右子树的值进行比较，并与其中小的进行交换（如果是大根，则将大的数目进行交换）
 3.重复上面的操作，直至叶子结点，将得到饿新的堆，称这个从堆顶至叶子结点的调整过程称为 “筛选”；

1.单结点的二叉树已经是堆了；
 2.叶子结点也是堆，因此我们堆排序是从最后一个非叶子结点开始,如果一棵完全二叉树有n结点，则到 它的非叶子结点的编号为n/2,
 因此我们只需要将 n/2,n/2-1 .....1这些二叉子树调整即可

建立小根堆，先将一组数进行0---n-1编号，然后初始值直接按需要生成一个完全二叉树；然后将这一组数字存到数组中，
比如说n=8,则 n/2=4,则对应的值为a【3】；
*/

/*
一、 堆满足条件：
    1.堆总是一种完全二叉树；
    2.堆中某个结点的值总是不大于或者不小于其父结点的值；
    3.将根结点最大的堆叫做最大堆或者大根堆，根结点值最小的叫做最小堆或小根堆，
    4.堆是非线性结构，相当于一维数组，有两个直接后继。
    5.若序列{k1,k2,…,kn}是堆，则堆顶元素（或完全二叉树的根）必为序列中n个元素的最小值（或最大值）。

二、建立堆的过程，假设一个小根堆的左右子树都是堆，并且根元素的名称是root，左子树为left，右子树为right,
    这种情况下有两种情况：
     1）root>left并且 root<right,此时堆已经建成
     2）root>=left 或者root >right,此时root应该与两个子女中交小的值进行交换，结果得到一个堆，除非root
       仍然大于其新子女的一个或者全部两个。这种情况下，我们只能简单的继续这种将"root“拉下来的过程，直至到
       达某一层使它小于它的子女，或者它成了叶子节点。
       (小顶堆的建立，大顶堆的操作是相反的，每次与根交换的是值大的孩子结点的值)
     3）建堆的时间复杂度为 0(n)
     4) 由于堆有logn层深度，插入结点，删除普通元素和删除最小元素的平均时间代价和时间 复杂度为0（logn）;
    eg:已知以下一堆结点：
          结点： 49 38 65 97 76 13 27 49
   结点对应编号： 0   1 2  3  4  5  6  7
    1）找到完全二叉树中最后一个非叶子结点，8/2-1=3 最后一个非叶子结点为编号是3的结点，即97,然后根据当前结点与其
    左右孩子的大小关系调整，主要看shift（）函数

 三、堆排序：
        它针对的是完全二叉树，完全二叉树是使用顺序存储的，即直接使用一个数组即可，
       如果结点的编号从0开始编号，即如果当前父亲结点的编号是i，则它的左孩子结点的编号为2*i+1,
       右孩子的编号为 2*i+2 个，最后一个非叶子结点的编号为 （n/2）向下取整 -1，
 */

时间复杂度为o(nlogn) 空间性能 o（1）只需要交换的时候一个临时空间 也是不稳定的排序

void heapSort(int arr[], int n)
{
    int i, temp;
    for (i = n / 2 - 1; i >= 0; i--)
    {
        shift(arr, i, n - 1);
    }

    for (i = n - 1; i > 0; i--)
    {
        temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;
        shift(arr, 0, i - 1);
    }
}
void shift(int arr[], int low, int high){ //调整换序算法
    int i = low, j = 2 * 1 + 1; //i是当前结点，则j是i结点的左孩子
    int temp = arr[i];          //存放的是 初始i 位置的值
    while (j <= high)
    {if (j < high && arr[j] < arr[j + 1]){ ++j;}
        if (temp < arr[j]){
            arr[i] = arr[j];
            i = j;
            j = 2 * i + 1;
        }
        else {break;}
        arr[i] = temp;
    }
}