/* 散列查找
   根据关键字值来计算出关键字在表中的地址
   地址是关键值的一个函数，即哈希函数 hashTable
   ad=H(key)关键字key在表中的地址值为ad
   第一次hash:
   H(key)=key mode length;

   哈希冲突解决：
  Hi(key)=(H(key)+i)Mod len :将第一次hash的地址值 加上 i，然后求模取余len,
   i属于1~len-1,len为表的长度

  常见的Hash函数：
   1）.直接定址法：取关键字或者关键字的某个线性函数为Hash地址，即：
   H(key)=key 或者 H(key)=a*key+b; 其中a,b 为常数

   2) .数字分析法：如果你的关键字是数字，挑出来然后作为hash地址，不易产生冲突
    比如一系列电话号码，你会发现前8位重复的概率比较大，但是后4位不同，
    可以选择作为hash的地址
   3）. 平方取中法：取关键字平方后的中间几位作为Hash地址。一个数平方后的中间
   几位数和数的每一位都相关，
        由此得到的Hash地址随机性更大。不容易冲突  比如：123  123*123 =15129，
        就可以取512作为其hash地址
   4）.除留余数法： 取关键字某个不大于Hash表表长度为m的数据p,除后所得余数为Hash地址，即：
        H(key)=key mod p (p<=len);在本方法中p的选择特别重要，通常是选择小于或者等于len的最大素数，
        这样可以减少冲突。
常见解决冲突的方法：
   1）开放定地址方法： 如果通过hash函数算出来的地址已经被占用，则从当前位置开始往后移，
   直到找到地址为空的存入即可。
       该方法也叫做线性探查法。H(key)=(H(key)+i) mode len (1<=i<=n),
       特点：可以探测到表中所有的位置，但是容易产生堆积问题
   2） 平方探查法：设发生冲突的地址为d,则探测到的新地址为：
        d+1*1 , d-1*1, d+2*2  d-2*2 d+3*3 d-3*3.....
        特点：不可以探测到表中所有的位置（至少可以探测一半的位置），但是不易产生堆积问题
   4） 链地址法：直接将每个位置上冲突的元素用链表链接在一起，比如4的位置为 2,12,14，则使用
                链表 4:2-->12-->14,即：使用链表将该位置的元素全部串联起来
  */